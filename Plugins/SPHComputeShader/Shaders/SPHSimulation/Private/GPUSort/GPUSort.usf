#include "/Engine/Public/Platform.ush"

// 구조체 정의
//struct FEntry
//{
//    uint OriginalIndex;
//    uint Hash;
//    uint Key;
//};

// 버퍼 선언
RWStructuredBuffer<int3> Entries;
int NumEntries;
int GroupWidth;
int GroupHeight;
int StepIndex;

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void SortCS(uint3 DTid : SV_DispatchThreadID)
{
    uint i = DTid.x;
    uint hIndex = i & (GroupWidth - 1);
    uint indexLeft = hIndex + (GroupHeight + 1) * (i / GroupWidth);
    uint rightStepSize = StepIndex == 0 ? GroupHeight - 2 * hIndex : (GroupHeight + 1) / 2;
    uint indexRight = indexLeft + rightStepSize;

    if (indexRight >= NumEntries) 
        return;

    // 정렬 로직
    if (Entries[indexLeft][2] > Entries[indexRight][2]) //[2] = key
    {
        int3 temp = Entries[indexLeft];
        Entries[indexLeft] = Entries[indexRight];
        Entries[indexRight] = temp;
    }
}

RWStructuredBuffer<int> Offsets;

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void CalculateOffsetsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint threadIndex = DispatchThreadId.x;
    if (threadIndex >= NumEntries)
        return;
    
    // 현재 엔트리의 해시값과 이전 엔트리의 해시값을 비교
    int currentHash = Entries[threadIndex].z;
    int prevHash = threadIndex > 0 ? Entries[threadIndex - 1].z : -1;
    
    // 해시값이 바뀌는 지점이나 첫 번째 엔트리인 경우 오프셋 설정
    if (currentHash != prevHash)
    {
        Offsets[threadIndex] = threadIndex;
    }
}